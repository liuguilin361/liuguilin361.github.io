<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://liuguilin361.github.io name=base><title>
         Custom Allocators in Rust
        
    </title><meta content="Custom Allocators in Rust" property=og:title><link href=https://liuguilin361.github.io/fonts.css rel=stylesheet><link href=https://liuguilin361.github.io/atom.xml rel=alternate title=liuguilin type=application/atom+xml><link href=https://liuguilin361.github.io/theme/light.css rel=stylesheet><link href=https://liuguilin361.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://liuguilin361.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://liuguilin361.github.io/main.css media=screen rel=stylesheet><script src="https://liuguilin361.github.io/search_index.en.js?h=a8fc7d9847d0be4f2d05" defer></script><script src="https://liuguilin361.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://liuguilin361.github.io>liuguilin</a><div class=socials><a class=social href=liuguilin361@gmail.com rel=me> <img alt=email src=https://liuguilin361.github.io/icons/social/email.svg> </a><a class=social href=https://github.com/liuguilin361/ rel=me> <img alt=github src=https://liuguilin361.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://liuguilin361.github.io/posts style=margin-left:.25em>/posts</a><a href=https://liuguilin361.github.io/tags style=margin-left:.25em>/tags</a><a href=https://liuguilin361.github.io/projects style=margin-left:.25em>/projects</a><a href=https://liuguilin361.github.io/talks style=margin-left:.25em>/talks</a><a href=https://liuguilin361.github.io/about style=margin-left:.25em>/about</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://liuguilin361.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://liuguilin361.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://liuguilin361.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Custom Allocators in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2022-01-18</time> :: 968 Words <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://liuguilin361.github.io/tags/windows-kernel/>windows kernel</a>, <a class=post-tag href=https://liuguilin361.github.io/tags/rust/>rust</a> </span></div></div><section class=body><h2 id=preface>Preface</h2><p>I'm currently writing an AMD hypervisor in Rust and there I need to allocate memory for lots of different structures. And not all of them use the same memory, so I decided to create a helper structure to allocate and deallocate it for me.<h2 id=my-implementation>My Implementation</h2><p>My implementation has 2 different types:<ul><li><code>Normal</code>: non-paged pool memory allocated with <code>ExAllocatePoolWithTag</code><li><code>Contiguous</code>: physical memory allocated with <code>MmAllocateContiguousMemorySpecifyCacheNode</code></ul><p>The first implementation looked like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub enum </span><span style=color:#399ee6>AllocType </span><span>{
</span><span>    Normal</span><span style=color:#61676ccc>,
</span><span>    Contiguous</span><span style=color:#61676ccc>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>AllocatedMemory</span><span>&LTT>(NonNull&LTT>, AllocType)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl</span><span>&LTT> </span><span style=color:#399ee6>AllocatedMemory</span><span>&LTT> {
</span><span>     </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>alloc_normal</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#fa6e32>Self</span><span>> { </span><span style=color:#abb0b6;font-style:italic>/* allocate memory */ </span><span>}
</span><span>     </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>alloc_contiguous</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#fa6e32>Self</span><span>> { </span><span style=color:#abb0b6;font-style:italic>/* allocate memory */ </span><span>}
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Deref/DerefMut implementations skipped
</span><span>
</span><span style=color:#fa6e32>impl</span><span>&LTT> Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>AllocatedMemory</span><span>&LTT> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>1 </span><span>{
</span><span>            AllocType</span><span style=color:#ed9366>::</span><span>Normal </span><span style=color:#ed9366>=> </span><span>{ </span><span style=color:#abb0b6;font-style:italic>/* Free memory using ExFreePool */ </span><span>}
</span><span>            AllocType</span><span style=color:#ed9366>::</span><span>Contiguous </span><span style=color:#ed9366>=> </span><span>{ </span><span style=color:#abb0b6;font-style:italic>/* Free memory using MmFreeContiguousMemory */ </span><span>}
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Doesn't look too complicated, huh? That's exactly what I thought, but there is one big problem with this. Can you spot it?<p>Let's look at the following example code:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Bar { ... }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Foo { bar: AllocatedMemory&LTBar> }
</span><span>    </span><span style=color:#fa6e32>let</span><span> foo </span><span style=color:#ed9366>= </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> foo </span><span style=color:#ed9366>= </span><span>AllocatedMemory</span><span style=color:#ed9366>::</span><span>&LTFoo></span><span style=color:#ed9366>::</span><span>alloc_normal()</span><span style=color:#61676ccc>;
</span><span>        foo</span><span style=color:#ed9366>.</span><span>bar </span><span style=color:#ed9366>= </span><span>AllocatedMemory</span><span style=color:#ed9366>::</span><span>&LTBar></span><span style=color:#ed9366>::</span><span>alloc_contiguous()</span><span style=color:#61676ccc>;
</span><span>        foo
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Now, what do you think happens at the end of the scope?<ol><li>Both allocations will be dropped and deallocated<li>Only <code>bar</code> will be dropped and deallocated<li>Only <code>foo</code> will be dropped and deallocated<li>Nothing will be deallocated</ol><p>You might have guessed it. Answer 3 is correct. What happens to <code>bar</code>? It's simple: Because we aren't capturing <code>T</code> inside <code>AllocatedMemory</code>, the compiler thinks it can drop the allocation immediately. For some reason, the compiler even optimized the pointer to <code>0x0</code>, so if you run the code, the driver would crash due to an access violation ( <code>0xffffffffc0000005</code>) because we are passing a null pointer to <code>ExFreePool</code>/<code>MmFreeContiguousMemory</code>. We can't just add a check for it, because then we would be leaking memory.<p>Here's what I think is happening:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>{
</span><span>    </span><span style=color:#fa6e32>let</span><span> foo </span><span style=color:#ed9366>= </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> foo </span><span style=color:#ed9366>= </span><span>AllocatedMemory</span><span style=color:#ed9366>::</span><span>alloc_normal()</span><span style=color:#61676ccc>;
</span><span>        foo</span><span style=color:#ed9366>.</span><span>bar </span><span style=color:#ed9366>= </span><span>AllocatedMemory</span><span style=color:#ed9366>::</span><span>alloc_contiguous()</span><span style=color:#61676ccc>;
</span><span>        foo
</span><span>    }</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// End of scope: Bar is only used inside it, so it's dropped. 
</span><span>       </span><span style=color:#abb0b6;font-style:italic>//               Value is assigned to `bar`.
</span><span>} </span><span style=color:#abb0b6;font-style:italic>// End of scope: Foo is dropped.
</span></code></pre><p>In the disassembly, it looked like this. You can see the allocation with <code>MmAllocateContiguousMemorySpecifyCacheNode</code> and then in the last lines it immediately tries to deallocate it.<p><img alt=disassembly src=https://user-images.githubusercontent.com/26800596/150001862-8783b129-5c5c-40f4-84a9-f21c64c8e0d5.png><hr><p>This bug was driving me insane because I didn't know what was causing it. I tried so many different things that didn't work:<ul><li>Disabled all unneeded features<li>Disabled LTO (link-time-optimization)<li>Tried a ton of different compilation<li>Remove AllocType, to check if it was a compiler bug/optimization<li>Replaced <code>NonNull&LTT></code> with <code>*mut T</code></ul><p>After none of my fixes worked, I decided to consult the <a href=https://doc.rust-lang.org/nomicon/ffi.html>Rust Nomicon</a>. Unfortunately, that didn't solve my problems either. I learned about tricky scenarios and common mistakes again, but none of them helped me figure out a solution.<h2 id=looking-at-existing-implementations>Looking at existing implementations</h2><p>I already knew about <code>Box&LTT></code> and <code>Vec&LTT></code>, so I wondered how they are implemented behind the scenes because they work similarly.<h3 id=vec-t><code>Vec&LTT></code></h3><p><code>Vec&LTT></code> is backed by <a href=https://github.com/rust-lang/rust/blob/master/library/alloc/src/raw_vec.rs#L52-L56><code>RawVec</code></a> which uses <a href=https://github.com/rust-lang/rust/blob/master/library/core/src/ptr/unique.rs><code>Unique&LTT></code></a> for the data pointer. <code>Unique&LTT></code> is a wrapper around <code>NonNull&LTT></code>, but it behaves as if it was an instance of <code>T</code>. That's exactly what we want.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Vec</span><span>&LTT, A</span><span style=color:#61676ccc>:</span><span> Allocator = Global> {
</span><span>    buf</span><span style=color:#61676ccc>: </span><span>RawVec&LTT, A>,
</span><span>    len</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>RawVec</span><span>&LTT, A</span><span style=color:#61676ccc>:</span><span> Allocator = Global> {
</span><span>    ptr</span><span style=color:#61676ccc>: </span><span>Unique&LTT>,
</span><span>    cap</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>usize</span><span>,
</span><span>    alloc</span><span style=color:#61676ccc>:</span><span> A,
</span><span>}
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>repr</span><span>(transparent)]
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Unique</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#f51818>?</span><span>Sized> {
</span><span>    pointer</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*const</span><span> T,
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// NOTE: this marker has no consequences for variance, but is necessary
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// for dropck to understand that we logically own a `T`.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>//
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// For details, see:
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
</span><span>    _marker</span><span style=color:#61676ccc>: </span><span>PhantomData&LTT>,
</span><span>}
</span></code></pre><p>The <code>Drop</code> implementation also uses <code>#[may_dangle]</code> to assert that the destructor of a generic type is guaranteed to not access any expired data. You can read more about that in the <a href=https://doc.rust-lang.org/nomicon/dropck.html>Rust Nomicon - An Escape Hatch</a>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>unsafe impl</span><span><</span><span style=color:#f51818>#</span><span>[</span><span style=color:#399ee6>may_dangle</span><span>] </span><span style=color:#399ee6>T</span><span>, </span><span style=color:#399ee6>A</span><span>: </span><span style=color:#399ee6>Allocator</span><span>> </span><span style=color:#399ee6>Drop for RawVec</span><span>&LTT, A> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) { </span><span style=color:#abb0b6;font-style:italic>/* skipped */ </span><span>}
</span><span>}
</span></code></pre><p>I tried both implementing <code>Unique&LTT></code> and <code>#[may_dangle]</code>, but that didn't solve my problem.<h3 id=box-t><code>Box&LTT></code></h3><p>This one is much simpler because it's just a <code>Unique&LTT></code> pointer (so it asserts that <code>Box</code> owns the data).<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Box</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#f51818>?</span><span>Sized, A: Allocator = Global>(Unique&LTT>, A)</span><span style=color:#61676ccc>;
</span></code></pre><p>There are many different allocator implementations, but I was only interested in one thing: the <code>Drop</code> implementation. I thought: "Maybe they do some black magic, to make sure that the inner elements are dropped correctly". And yes, they do, because there's <strong>literally nothing</strong>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>unsafe impl</span><span><</span><span style=color:#f51818>#</span><span>[</span><span style=color:#399ee6>may_dangle</span><span>] </span><span style=color:#399ee6>T</span><span>: ?</span><span style=color:#399ee6>Sized</span><span>, </span><span style=color:#399ee6>A</span><span>: </span><span style=color:#399ee6>Allocator</span><span>> </span><span style=color:#399ee6>const Drop for Box</span><span>&LTT, A> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// FIXME: Do nothing, drop is currently performed by compiler.
</span><span>    }
</span><span>}
</span></code></pre><hr><p>Since none of my previous attempts worked, I tried to replace <code>AllocatedMemory&LTT></code> with <code>Box&LTT></code>, but it still didn't work. I tried a few different examples and figured out the problem.<p>Here's the what the structures look like:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Bar </span><span>{
</span><span>    value</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>,
</span><span>}
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Foo </span><span>{
</span><span>    bar</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTBar>,
</span><span>}
</span></code></pre><p>For example, this code works:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> bar </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#61676ccc>::</span><span>&LTBar></span><span style=color:#ed9366>::</span><span>new_zeroed()</span><span style=color:#ed9366>.</span><span style=color:#f07171>assume_init</span><span>() }</span><span style=color:#61676ccc>;
</span><span>    bar</span><span style=color:#ed9366>.</span><span>value </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> foo </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(Foo { bar })</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Yet these two examples don't work:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTFoo> </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#61676ccc>::</span><span>&LTFoo></span><span style=color:#ed9366>::</span><span>new_zeroed()</span><span style=color:#ed9366>.</span><span style=color:#f07171>assume_init</span><span>() }</span><span style=color:#61676ccc>;
</span><span>    foo</span><span style=color:#ed9366>.</span><span>bar </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(Bar { value</span><span style=color:#61676ccc>: </span><span style=color:#ff8f40>42 </span><span>})</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> bar </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#61676ccc>::</span><span>&LTBar></span><span style=color:#ed9366>::</span><span>new_zeroed()</span><span style=color:#ed9366>.</span><span style=color:#f07171>assume_init</span><span>() }</span><span style=color:#61676ccc>;
</span><span>    bar</span><span style=color:#ed9366>.</span><span>value </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTFoo> </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#61676ccc>::</span><span>&LTFoo></span><span style=color:#ed9366>::</span><span>new_zeroed()</span><span style=color:#ed9366>.</span><span style=color:#f07171>assume_init</span><span>() }</span><span style=color:#61676ccc>;
</span><span>    foo</span><span style=color:#ed9366>.</span><span>bar </span><span style=color:#ed9366>=</span><span> bar</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p><code>Box::new_zeroed()</code> refers to the <code>MaybeUninit::zeroed()</code> documentation, which mentions the following:<blockquote><p>Note that dropping a <code>MaybeUninit&LTT></code> will never call T's drop code. It is your responsibility to make sure T gets dropped if it got initialized.</blockquote><p>So it is actually not the Rust compiler that's wrong, it's me. I'm still not sure why my <code>AllocatedMemory</code> implementations were not working, but I now know that lots of effort has been put into making <code>Box&LTT></code> sound and safe.<h2 id=final-solution>Final solution</h2><p>While going through the <a href=https://github.com/rust-lang/rust/blob/master/library/alloc/src/boxed.rs>source code of <code>Box&LTT></code></a> I also noticed the new <a href=https://doc.rust-lang.org/beta/unstable-book/library-features/allocator-api.html>allocator api</a>. Because I needed to redesign the <code>AllocatedMemory</code> structure, I decided to use <code>Box</code> with custom allocators instead.<p>I already have a <a href=https://github.com/not-matthias/kernel-alloc-rs>global allocator</a> which allocates pool memory, so I only need to write one for physical memory. We only have to implement the <code>Allocator</code> trait, and we are good to go:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>PhysicalAllocator</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>unsafe impl </span><span>Allocator </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>PhysicalAllocator </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>allocate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>layout</span><span style=color:#61676ccc>:</span><span> Layout) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTNonNull<[</span><span style=color:#fa6e32>u8</span><span>]>, AllocError> {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>/* allocate physical memory and return it */
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>deallocate</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>ptr</span><span style=color:#61676ccc>: </span><span>NonNull<</span><span style=color:#fa6e32>u8</span><span>>, </span><span style=color:#ff8f40>layout</span><span style=color:#61676ccc>:</span><span> Layout) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>/* deallocate physical memory */
</span><span>    }
</span><span>}
</span></code></pre><p>Now we can either pass <code>alloc::Global</code> or <code>PhysicalAllocator</code> to the functions like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span><</span><span style=color:#fa6e32>u64</span><span>, PhysicalAllocator> </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new_in(</span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>,</span><span> PhysicalAllocator)</span><span style=color:#61676ccc>;
</span></code></pre><p>Instead of passing <code>alloc::Global</code> (the global allocator) to <code>Box::new_in</code>, we can also just use the default implementation <code>Box::new</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>global_allocator</span><span>]
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>GLOBAL</span><span style=color:#61676ccc>:</span><span> KernelAlloc </span><span style=color:#ed9366>=</span><span> KernelAlloc</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span><</span><span style=color:#fa6e32>u64</span><span>> </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new_in(</span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>, </span><span>alloc</span><span style=color:#ed9366>::</span><span>Global)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span><</span><span style=color:#fa6e32>u64</span><span>> </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>42</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>There's even fallible allocations if you want to handle the allocation errors yourself. <code>Box::new_in</code> is just a wrapper around <code>Box::try_new_in</code> and calls <code>handle_alloc_error(layout)</code> upon failure.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> foo</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span><</span><span style=color:#fa6e32>u64</span><span>, PhysicalAllocator> </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>match </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>try_new_in(</span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>,</span><span> PhysicalAllocator) {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(foo) </span><span style=color:#ed9366>=></span><span> foo</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(e) </span><span style=color:#ed9366>=> </span><span style=color:#abb0b6;font-style:italic>/* handle alloc error */
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><p>So now, instead of using <code>AllocatedMemory&LTT></code>, we can use <code>Box&LTT></code> and get rid of all the bugs and crashes.<h2 id=conclusion>Conclusion</h2><p>I actually really like this change. We can reuse existing implementations and allocate it <strong>wherever we want</strong>. We also reduced the amount of code we have to manage and other people can understand the code more easily.<p>I also think I'd have a hard time trying to implement <code>Drop</code> myself when <code>Box</code> is using the compiler for that. There's probably a good reason for that. If you know why, please let me know.<hr><p>Thanks for reading.</section></article></main></div>