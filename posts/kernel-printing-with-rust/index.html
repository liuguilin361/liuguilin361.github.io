<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://liuguilin361.github.io name=base><title>
         Kernel printing with Rust
        
    </title><meta content="Kernel printing with Rust" property=og:title><link href=https://liuguilin361.github.io/fonts.css rel=stylesheet><link href=https://liuguilin361.github.io/atom.xml rel=alternate title=liuguilin type=application/atom+xml><link href=https://liuguilin361.github.io/theme/light.css rel=stylesheet><link href=https://liuguilin361.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://liuguilin361.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://liuguilin361.github.io/main.css media=screen rel=stylesheet><script src="https://liuguilin361.github.io/search_index.en.js?h=a8fc7d9847d0be4f2d05" defer></script><script src="https://liuguilin361.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://liuguilin361.github.io>liuguilin</a><div class=socials><a class=social href=liuguilin361@gmail.com rel=me> <img alt=email src=https://liuguilin361.github.io/icons/social/email.svg> </a><a class=social href=https://github.com/liuguilin361/ rel=me> <img alt=github src=https://liuguilin361.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://liuguilin361.github.io/posts style=margin-left:.25em>/posts</a><a href=https://liuguilin361.github.io/tags style=margin-left:.25em>/tags</a><a href=https://liuguilin361.github.io/projects style=margin-left:.25em>/projects</a><a href=https://liuguilin361.github.io/talks style=margin-left:.25em>/talks</a><a href=https://liuguilin361.github.io/about style=margin-left:.25em>/about</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://liuguilin361.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://liuguilin361.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://liuguilin361.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Kernel printing with Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-08-21</time> :: Updated on <time>2022-08-16</time> :: 2375 Words <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://liuguilin361.github.io/tags/windows-kernel/>windows kernel</a>, <a class=post-tag href=https://liuguilin361.github.io/tags/rust/>rust</a> </span></div></div><section class=body><p><strong>Update</strong>: I recommend using the <a href=https://crates.io/crates/log><code>log</code></a> and <a href=https://crates.io/crates/kernel-log><code>kernel-log</code></a> crates for kernel logging. For more information, visit <a href=http://not-matthias.github.io/posts/kernel-driver-with-rust-2022/> Kernel Driver with Rust in 2022</a>.<h2 id=preface>Preface</h2><p>Printing is important. If something doesn't work, you want to know <strong>why</strong> (e.g. by looking at the console output). When I first wrote the <a href=https://github.com/not-matthias/kernel-driver-with-rust/blob/master/src/log.rs>log macro</a> for my kernel driver I didn't think much about the security. I just thought: "Surely nobody will call it with the wrong format specifiers or the wrong number of arguments, because the usage is simple and straightforward".<p>As you probably can guess, this is against all the principles of Rust. If you use <code>unsafe</code> you need to ensure that the implementation is safe. This way you can be sure that the driver will be fine when there are no compiler warnings.<p>So let's make it a little safer.<h2 id=determining-the-problem>Determining the problem</h2><p>I already gave it away. The problem is the variadic function <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-dbgprint>DbgPrint</a> which does not verify whether you called it with the correct parameters. So there's no link between the arguments and format specifiers. Thus it would be possible to do something like this with our current implementation:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#f07171>log!</span><span>(</span><span style=color:#86b300>"[%i] %s (%p)"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"0"</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>In the best case we just crash, but this can also be exploited and be a critical security vulnerability. In fact, this is exactly what <a href=https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro/#format-string-vulnerability-principle>Format String Attacks</a> do. If you are interested in this topic, I recommend checking out the article <a href=https://cs155.stanford.edu/papers/formatstring-1.2.pdf>Exploiting Format String Vulnerabilities</a> from 2001.<h2 id=solution-1>Solution 1</h2><p>Hmm, so can't you just compare the format specifier count with the number of arguments? Well yes, but actually no. In order to better understand the reason behind this, here's the macro from the last post.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>log </span><span>{
</span><span>    ($string: expr, </span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$x</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>tt</span><span>)</span><span style=color:#ed9366>*</span><span>) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>            $crate</span><span style=color:#ed9366>::</span><span>DbgPrint(</span><span style=color:#f07171>concat!</span><span>(</span><span style=color:#86b300>"[>] "</span><span style=color:#61676ccc>, </span><span>$string</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>$</span><span>($x)</span><span style=color:#ed9366>*</span><span>)
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>We could theoretically check the number of the format specifiers using something like <code>.matches("%").count()</code>, but this is already flawed. We also need to check whether the format specifier even exists, as you can pass a percent sign whenever you want. As you can see, this gets complicated fast.<p>Another problem is the counting of the parameters as we are just accepting any <a href=https://doc.rust-lang.org/reference/macros-by-example.html#metavariables>TokenTree</a> elements and pass it to <code>DbgPrint</code>. We could just update the repetition to <code>$($x:expr $(,)?)*</code> but then we also need to somehow get the count. This requires some tricks, but luckily other people already <a href=https://danielkeep.github.io/tlborm/book/blk-counting.html>thought about this</a>.<p>To summarize: We would need to check for every possible use case which is really complex and error-prone. These checks also only happen at runtime so we need to think about how we would want to handle those errors. Do we panic? Do we just do nothing? Do we print an error message? This slows down development and testing drastically as there's no instant feedback from the compiler anymore.<p>Maybe there's an easier way to do this.<h2 id=solution-2>Solution 2</h2><p>When I posted the article <a href=https://not-matthias.github.io/kernel-driver-with-rust/>Writing a kernel driver with Rust</a> on Reddit, <a href=https://www.reddit.com/u/daniel5151/>/u/daniel5151</a> pointed out that the log macro can be pretty dangerous.<p><a class=embedly-card href=https://www.reddit.com/r/rust/comments/hrwyl8/writing_a_kernel_driver_with_rust/fy7fnyw>Card</a></p><script async charset=UTF-8 src=//embed.redditmedia.com/widgets/platform.js></script><p>When I first looked at the source code of the mentioned library, I didn't realize that it was using the <a href=https://doc.rust-lang.org/std/macro.format_args.html>format_args</a> macro. A short time later, <a href=https://github.com/czapek1337>czapek</a> mentioned that I could use <code>format_args</code> which would allow me to replicate the printing macros of the standard library.<p>After taking a closer look at the Github repository, I noticed that it was also using <code>format_args</code> so I decided to create a library for kernel drivers. Let's explore how this works.<p>If you would have access to the standard library, you could use <a href=https://doc.rust-lang.org/std/string/trait.ToString.html>ToString</a> to convert the return value of the <code>format_args</code> macro. However, as the <code>String</code> type is not available in the core library, we cannot use that. A workaround for this would be the <code>alloc</code> crate, but I didn't like this approach as it requires a custom allocator and heap allocations. You might now wonder: Is it possible to convert it to <code>&str</code>? Well, I'm glad you asked. Recently a new feature called <a href=https://doc.rust-lang.org/nightly/unstable-book/library-features/fmt-as-str.html>fmt_as_str</a> has been added, but as of the release date of this post, it's still fairly limited. Currently, you can only get the formatted string if it has no arguments. So if we also wanted to use arguments, we would have to use a hybrid approach:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#!</span><span>[</span><span style=color:#f29718>feature</span><span>(fmt_as_str)]
</span><span>
</span><span style=color:#fa6e32>use </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Arguments</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_str</span><span>(</span><span style=color:#ed9366>_</span><span>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>/* ... */
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_fmt</span><span>(</span><span style=color:#ff8f40>args</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>Arguments) {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(s) </span><span style=color:#ed9366>=</span><span> args</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_str</span><span>() {
</span><span>        </span><span style=color:#f07171>write_str</span><span>(s)
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#f07171>write_str</span><span>(</span><span style=color:#ed9366>&</span><span>args</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_string</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span></code></pre><p>If you look closely, you can see the <code>to_string</code> call, so we are back to zero. So is there any way that we can the formatted string slice? Let's look at the documentation of <a href=https://doc.rust-lang.org/core/macro.format_args.html>format_args!</a> again. Maybe we missed something.<blockquote><p>This macro produces a value of type <a href=https://doc.rust-lang.org/std/fmt/struct.Arguments.html>fmt::Arguments</a>. This value can be passed to the macros within <a href=https://doc.rust-lang.org/std/fmt/index.html>std::fmt</a> for performing useful redirection. All other formatting macros (<a href=https://doc.rust-lang.org/std/macro.format.html>format!</a>, <a href=https://doc.rust-lang.org/std/macro.write.html>write!</a>, <a href=https://doc.rust-lang.org/std/macro.println.html>println!</a>, etc) are proxied through this one. <code>format_args!</code>, unlike its derived macros, avoids heap allocations.</blockquote><p>Hmmm, so all these links are referencing the standard library. The reason behind this is probably to have all the documentation in one place as it is just <a href=https://github.com/rust-lang/rust/blob/master/library/std/src/lib.rs#L379>reexporting</a> it from the <code>alloc</code> crate (which actually <a href=https://github.com/rust-lang/rust/blob/master/library/alloc/src/fmt.rs#L532-L551>reexports</a> it from the <code>core</code> crate).<p>The only macro that exists in the core crate is <a href=https://doc.rust-lang.org/core/macro.write.html>write!</a>. After reading the documentation, you'll quickly realize that it's quite similar to the <code>format_args!</code> macro. Instead of return <code>fmt::Arguments</code> it writes it to a buffer. There's one example that caught my eye.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Example</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span>Write </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Example </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_str</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>_s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>         </span><span style=color:#f07171>unimplemented!</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> m </span><span style=color:#ed9366>=</span><span> Example{}</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>write!</span><span>(&mut m, </span><span style=color:#86b300>"Hello World"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"Not written"</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>It seems like we can use the <code>Write</code> trait to specify where we want to write to. In this example, we'll probably get the formatted string slice as a parameter for the <code>write_str</code> trait function. As I'm not 100% sure about that, I'm using the option to run the code sample on the <a href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20core%3B%0Afn%20main()%20%7B%0Ause%20core%3A%3Afmt%3A%3AWrite%3B%0A%0Astruct%20Example%3B%0A%0Aimpl%20Write%20for%20Example%20%7B%0A%20%20%20%20fn%20write_str(%26mut%20self%2C%20_s%3A%20%26str)%20-%3E%20core%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20%20unimplemented!()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20mut%20m%20%3D%20Example%7B%7D%3B%0Awrite!(%26mut%20m%2C%20%22Hello%20World%22).expect(%22Not%20written%22)%3B%0A%7D&edition=2018">Rust Playground</a> by clicking on the <code>Run</code> button in the top right corner. When I adjust the source code to actually pass a parameter and print it, it works as expected.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#!</span><span>[</span><span style=color:#f29718>allow</span><span>(unused)]
</span><span style=color:#fa6e32>extern crate</span><span> core</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {
</span><span>    </span><span style=color:#fa6e32>use </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Example</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>impl </span><span>Write </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Example </span><span>{
</span><span>        </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_str</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>_s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>             </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> _s)</span><span style=color:#61676ccc>;
</span><span>             </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>        }
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> m </span><span style=color:#ed9366>=</span><span> Example{}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>write!</span><span>(&mut m, </span><span style=color:#86b300>"Hello World: </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>42</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"Not written"</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>But having to call <code>write!</code> whenever we want to log something to the console is pretty complicated. I'm sure there's a better way to do this. We can again look at the source code and try to understand how it works. Luckily it's just a simple wrapper that calls the <code>write_fmt</code> function with the return value of the <code>format_args!</code> macro.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>macro_export</span><span>]
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>stable</span><span>(feature </span><span style=color:#ed9366>= </span><span style=color:#86b300>"rust1"</span><span style=color:#61676ccc>,</span><span> since </span><span style=color:#ed9366>= </span><span style=color:#86b300>"1.0.0"</span><span>)]
</span><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>write </span><span>{
</span><span>    (</span><span style=color:#ff8f40>$dst</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>expr</span><span>, </span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$arg</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>tt</span><span>)</span><span style=color:#ed9366>*</span><span>) </span><span style=color:#ed9366>=> </span><span>($dst</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_fmt</span><span>($crate</span><span style=color:#ed9366>::</span><span>format_args</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#ed9366>$</span><span>($arg)</span><span style=color:#ed9366>*</span><span>)))
</span><span>}
</span></code></pre><p>Finally! That's exactly what I was looking for. A way to use the result of <code>format_args</code> (which has the type <code>fmt::Arguments</code>). In this case, we just have to implement the <code>Writer</code> trait and create our own <code>write_str</code> function which then prints the formatted string. That's actually easier than I thought it would be.<p>So let's start by creating our structure and implement <code>Write</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>KernelWriter</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>KernelWriter </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>write_str</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>        </span><span style=color:#f07171>__kernel_println</span><span>(s)
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>__kernel_println</span><span>(</span><span style=color:#ff8f40>msg</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>    </span><span style=color:#fa6e32>unsafe </span><span>{ ntapi</span><span style=color:#ed9366>::</span><span>ntdbg</span><span style=color:#ed9366>::</span><span>DbgPrint(msg</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>() </span><span style=color:#ed9366>as _</span><span>) }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><p>If you read the <a href=https://not-matthias.github.io/kernel-driver-with-rust/>previous article</a>, you'll notice that I'm not using the <a href=https://github.com/Trantect/winapi-rs>winapi</a> crate. After I published the article I remembered that the <a href=https://github.com/MSxDOS/ntapi>ntapi</a> crate exists. There's also a <code>kernel</code> feature which can be used in our driver. We can add the following to our <code>Crates.toml</code> and then we are good to go:<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[</span><span style=color:#399ee6>dependencies</span><span>]
</span><span style=color:#399ee6>ntapi </span><span>= { </span><span style=color:#399ee6>version </span><span>= </span><span style=color:#86b300>"0.3.4"</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>default-features </span><span>= </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span style=color:#399ee6>features </span><span>= [</span><span style=color:#86b300>"kernel"</span><span>] }
</span></code></pre><p>Okay, but having to instantiate the <code>KernelWriter</code> structure and calling the methods whenever we want to print things is a lot of effort and kind of complicated. We can replicate macros like <code>println!</code> and <code>dbg!</code> but we should also create some helper methods that make using it easier.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#399ee6>KernelWriter </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub const fn </span><span style=color:#f29718>new</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>Self </span><span>{
</span><span>        </span><span style=color:#fa6e32>Self
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>write_fmt</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>args</span><span style=color:#61676ccc>: </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Arguments) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>        core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write</span><span style=color:#ed9366>::</span><span>write_fmt(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>,</span><span> args)
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>write_str</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>        core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write</span><span style=color:#ed9366>::</span><span>write_str(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>,</span><span> s)
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>write_nl</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>        </span><span style=color:#f07171>__kernel_println</span><span>(</span><span style=color:#86b300>"</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span>)
</span><span>    }
</span><span>}
</span></code></pre><p>The constructor and <code>write_nl</code> should be self-explanatory. When you see <code>write_fmt</code> and <code>write_str</code> you might wonder why those exist. Well, if you wanted to use the kernel writer and call the functions defined in the <code>Write</code> trait (like <code>write_fmt</code> or <code>write_fmt</code>), you would have to import the trait or call it directly.<p>Importing the trait inside a macro won't work as it's possibly redefining it. The following code will fail with the error <code>error[E0252]: the name Write is defined multiple times</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>kernel_println </span><span>{
</span><span>    (</span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$arg</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>tt</span><span>)</span><span style=color:#ed9366>*</span><span>) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#fa6e32>use </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Write</span><span style=color:#61676ccc>;
</span><span>
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> writer </span><span style=color:#ed9366>= </span><span>KernelWriter</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>        writer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_fmt</span><span>(</span><span style=color:#f07171>format_args!</span><span>(</span><span style=color:#ed9366>$</span><span>($arg)</span><span style=color:#ed9366>*</span><span>))</span><span style=color:#61676ccc>;
</span><span>        writer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_nl</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>test_println</span><span>() {
</span><span>    </span><span style=color:#f07171>kernel_println!</span><span>(</span><span style=color:#86b300>"Hello World"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>kernel_println!</span><span>(</span><span style=color:#86b300>"Hello World"</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>We could wrap the entire macro inside <code>{}</code> so we can import it for different scopes. I didn't like that approach, that's why I decided to just call the function directly. We could also just do that in the macro, but moving it to the structure reduces the amount of code we have to write.<p>Okay, so we finished the writer implementation, now we can finally implement our macros. They are pretty straightforward. We can just create a new <code>KernelWriter</code> instance, call <code>format_args</code> and pass it to <code>write_fmt</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>kernel_println </span><span>{
</span><span>    () </span><span style=color:#ed9366>=> </span><span>{ $crate</span><span style=color:#ed9366>::</span><span>kernel_println</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>""</span><span>) }</span><span style=color:#61676ccc>;
</span><span>    (</span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$arg</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>tt</span><span>)</span><span style=color:#ed9366>*</span><span>) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        {
</span><span>            </span><span style=color:#fa6e32>let mut</span><span> writer </span><span style=color:#ed9366>= </span><span>$crate</span><span style=color:#ed9366>::</span><span>writer</span><span style=color:#ed9366>::</span><span>KernelWriter</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ =</span><span> writer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_fmt</span><span>(</span><span style=color:#f07171>format_args!</span><span>(</span><span style=color:#ed9366>$</span><span>($arg)</span><span style=color:#ed9366>*</span><span>))</span><span style=color:#61676ccc>;
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ =</span><span> writer</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_nl</span><span>()</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Everything that has been mentioned until here has already been implemented in the <a href=https://github.com/mmastrac/rust-libc-print/>rust-libc-print</a> project. When I was looking through the issues, I noticed that someone was asking about the <code>dbg!</code> macro as it hasn't been implemented yet. I wasn't sure if that's even possible, so I decided to take a look at the macro definition.<p>It turns out that it only uses the <code>println!</code> macro combined with <code>file!</code>, <code>line!</code> and <code>stringify!</code>. We can just copy the code, update the <code>println!</code> macro to use our custom macro and we are done. Pretty easy, right?<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>macro_export</span><span>]
</span><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>kernel_dbg </span><span>{
</span><span>    () </span><span style=color:#ed9366>=> </span><span>{
</span><span>        $crate</span><span style=color:#ed9366>::</span><span>println</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"[{}:{}]"</span><span style=color:#61676ccc>, </span><span style=color:#f07171>file!</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#f07171>line!</span><span>())</span><span style=color:#61676ccc>;
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    (</span><span style=color:#ff8f40>$val</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>expr</span><span>) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Use of `match` here is intentional because it affects the lifetimes
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// of temporaries - https://stackoverflow.com/a/48732525/1063961
</span><span>        </span><span style=color:#fa6e32>match </span><span>$val {
</span><span>            tmp </span><span style=color:#ed9366>=> </span><span>{
</span><span>                $crate</span><span style=color:#ed9366>::</span><span>println</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"[{}:{}] {} = {:#?}"</span><span style=color:#61676ccc>,
</span><span>                    </span><span style=color:#f07171>file!</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#f07171>line!</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#f07171>stringify!</span><span>($val)</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>tmp)</span><span style=color:#61676ccc>;
</span><span>                tmp
</span><span>            }
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Trailing comma with single argument is ignored
</span><span>    (</span><span style=color:#ff8f40>$val</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>expr</span><span>,) </span><span style=color:#ed9366>=> </span><span>{ $crate</span><span style=color:#ed9366>::</span><span>dbg</span><span style=color:#ed9366>!</span><span>($val) }</span><span style=color:#61676ccc>;
</span><span>    (</span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$val</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>expr</span><span>),</span><span style=color:#ed9366>+ $</span><span>(,)?) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        (</span><span style=color:#ed9366>$</span><span>($crate</span><span style=color:#ed9366>::</span><span>dbg</span><span style=color:#ed9366>!</span><span>($val))</span><span style=color:#61676ccc>,</span><span style=color:#ed9366>+</span><span style=color:#61676ccc>,</span><span>)
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Alright, let's use the logging crate in the existing <a href=https://github.com/not-matthias/kernel-driver-with-rust>driver project</a> and add the following.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>no_mangle</span><span>]
</span><span style=color:#fa6e32>pub extern </span><span style=color:#86b300>"system" </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>driver_entry</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u32 </span><span>{
</span><span>    kernel_print</span><span style=color:#ed9366>::</span><span>kernel_dbg</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#ff8f40>2 </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>;
</span><span>    kernel_print</span><span style=color:#ed9366>::</span><span>kernel_print</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"{} + {} = {}</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2 </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>;
</span><span>    kernel_print</span><span style=color:#ed9366>::</span><span>kernel_println</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"{} + {} = {}"</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2 </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ff8f40>0 </span><span style=color:#abb0b6;font-style:italic>/* STATUS_SUCCESS */
</span><span>}
</span></code></pre><p>Wait, if you try to run it, it doesn't work? That's weird. Why does it work when using <a href=https://github.com/mmastrac/rust-libc-print>rust-libc-print</a> but not for our implementation?<pre style=color:#61676c;background-color:#fafafa><code><span>[:]  = src/lib.rs:]  = 56]  = 2 + 2 = 0„û…Šÿÿ4 
</span><span> + 2 + 2 = 4 
</span><span> + 2 + 2 = 4 
</span></code></pre><p>After some time and looking at the output, I recognized patterns. Between the strings, there are non-printable bytes and at the end, there's <code>û…Šÿÿ4</code>. Wait a minute, does the writer not know where our strings end? That's it. The strings in rust are not null-terminated (<code>\0</code>) so when we pass the string as a pointer to <code>DbgPrint</code> there's no way it can know where it ends.<p>Alright, we know what's wrong but how can we fix it? Well, it's not that simple. Currently, we know the exact size of the string that needs to be printed so it can be allocated on the stack. If we wanted to add additional characters, there's no way to guarantee that we have enough space on the stack.<p>To get around this, we have to use a custom allocator. I really tried to avoid it, but it seems like it's the only way. I decided to create a <a href=https://crates.io/crates/kernel-alloc>crate</a> so that other people can also use it.<p>The implementation is simple and straightforward. We just need to implement the <code>GlobalAlloc</code> trait. You also need to implement the definitions and an allocation error handler, which have been left out for the sake of simplicity.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>KernelAlloc</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>unsafe impl </span><span>GlobalAlloc </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>KernelAlloc </span><span>{
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>alloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>layout</span><span style=color:#61676ccc>:</span><span> Layout) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>*mut u8 </span><span>{
</span><span>        </span><span style=color:#fa6e32>let</span><span> pool </span><span style=color:#ed9366>=</span><span> ExAllocatePool(PoolType</span><span style=color:#ed9366>::</span><span>NonPagedPool</span><span style=color:#61676ccc>,</span><span> layout</span><span style=color:#ed9366>.</span><span style=color:#f07171>size</span><span>())</span><span style=color:#61676ccc>;
</span><span>
</span><span>        </span><span style=color:#fa6e32>if</span><span> pool</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_null</span><span>() {
</span><span>            </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"[kernel-alloc] failed to allocate pool."</span><span>)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>
</span><span>        pool </span><span style=color:#ed9366>as _
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>unsafe fn </span><span style=color:#f29718>dealloc</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>ptr</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>*mut u8</span><span>, </span><span style=color:#ff8f40>_layout</span><span style=color:#61676ccc>:</span><span> Layout) { ExFreePool(ptr </span><span style=color:#ed9366>as _</span><span>)</span><span style=color:#61676ccc>; </span><span>}
</span><span>}
</span></code></pre><p>If you want to use the allocator in your project, you have to define a global allocator. If you are developing a library, you don't need to do that. You can just specify that you need to use the <code>alloc</code> crate and if someone tries to use this library without an allocator, an error will be shown. If you want to use the library, you have to add the following code:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>global_allocator</span><span>]
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>GLOBAL</span><span style=color:#61676ccc>:</span><span> KernelAlloc </span><span style=color:#ed9366>=</span><span> KernelAlloc</span><span style=color:#61676ccc>;
</span></code></pre><p>Now that we can allocate memory on the heap, we have to think about the best way to utilize this. Because the strings passed to the <code>DbgPrint</code> function are the primary problem, we can just append the null terminator.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>unsafe </span><span>{ ntapi</span><span style=color:#ed9366>::</span><span>ntdbg</span><span style=color:#ed9366>::</span><span>DbgPrint(alloc</span><span style=color:#ed9366>::</span><span>format</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"{}</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> msg)</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>() </span><span style=color:#ed9366>as _</span><span>) }</span><span style=color:#61676ccc>;
</span></code></pre><p>Let's try to run our example driver again. Awesome, it works!<pre style=color:#61676c;background-color:#fafafa><code><span>[src/lib.rs:58] 2 + 2 = 4 
</span><span>2 + 2 = 4 
</span><span>2 + 2 = 4
</span></code></pre><h2 id=solution-3>Solution 3</h2><p>The previous implementation is pretty complicated and can be simplified now that we are using an allocator anyway. Instead of using <code>format_args!</code> and then passing the result to <code>core::fmt::Write</code>, we can just directly call <code>format!</code>. This would then look something like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> string </span><span style=color:#ed9366>= </span><span>alloc</span><span style=color:#ed9366>::</span><span>format</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#ed9366>$</span><span>($arg)</span><span style=color:#ed9366>*</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>__kernel_println</span><span>(string)</span><span style=color:#61676ccc>;
</span></code></pre><p>I decided to update the <code>__kernel_println</code> function so that we can pass both <code>&str</code> and <code>String</code> but still append the null-terminator. This way we can easily pass the output of <code>format!</code> without having to update the already written code. Using <code>Into&LTString></code> also reduces the number of allocations because only string slices (<code>&str</code>) need to be converted.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>__kernel_println</span><span>&LTS</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Into</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>>(</span><span style=color:#ff8f40>string</span><span style=color:#61676ccc>:</span><span> S) </span><span style=color:#61676ccc>-> </span><span>core</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Result {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Add the null-terminator to the string.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>//
</span><span>    </span><span style=color:#fa6e32>let</span><span> string </span><span style=color:#ed9366>= </span><span>{
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> temp </span><span style=color:#ed9366>=</span><span> string</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>()</span><span style=color:#61676ccc>;
</span><span>        temp</span><span style=color:#ed9366>.</span><span style=color:#f07171>push</span><span>(</span><span style=color:#86b300>'</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>'</span><span>)</span><span style=color:#61676ccc>;
</span><span>        temp
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Print the null-terminated string.
</span><span>    </span><span style=color:#abb0b6;font-style:italic>//
</span><span>    </span><span style=color:#fa6e32>unsafe </span><span>{ ntapi</span><span style=color:#ed9366>::</span><span>ntdbg</span><span style=color:#ed9366>::</span><span>DbgPrint(string</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>() </span><span style=color:#ed9366>as _</span><span>) }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(())
</span><span>}
</span></code></pre><h2 id=conclusion>Conclusion</h2><p>This post basically only exists because <strike>I was lazy</strike> I thought that it's just a proof of concept, that the usage is clear and that I can worry about the safety later. Even though I was only playing around, I should have implemented it properly in the first place to spare me the trouble later on. I hope you learned something from my mistakes. An example utilizing the <a href=https://crates.io/crates/kernel-print>kernel-print</a> crate can be found in the <a href=https://github.com/not-matthias/kernel-driver-with-rust/blob/master/src/lib.rs#L49-L51>kernel-driver-with-rust</a> repository.<p>Shoutout to <a href=https://www.reddit.com/u/daniel5151/>/u/daniel5151</a> and <a href=https://github.com/czapek1337>czapek</a> for recognizing the problem and providing helpful information, resources and examples.<p>Thanks for reading!</section></article></main></div>