<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://liuguilin361.github.io name=base><title>
         Benchmarking Caches in Rust
        
    </title><meta content="Benchmarking Caches in Rust" property=og:title><link href=https://liuguilin361.github.io/fonts.css rel=stylesheet><script data-host-url=https://api-gateway.umami.dev/ data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e defer src=/js/imamu.js></script><script async data-goatcounter=https://not-matthias.goatcounter.com/count src=https://liuguilin361.github.io/js/count.js></script><noscript><img src="https://not-matthias.goatcounter.com//count?p=/posts/cache-bench/&t=Benchmarking Caches in Rust"></noscript><link title="liuguilin's blog" href=https://liuguilin361.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://liuguilin361.github.io/theme/light.css rel=stylesheet><link href=https://liuguilin361.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://liuguilin361.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://liuguilin361.github.io/main.css media=screen rel=stylesheet><script src="https://liuguilin361.github.io/search_index.en.js?h=b0e86fa6164ec2b23997" defer></script><script src="https://liuguilin361.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://liuguilin361.github.io>liuguilin's blog</a><div class=socials><a class=social href=https://twitter.com/not_matthias rel=me> <img alt=twitter src=https://liuguilin361.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/liuguilin361/ rel=me> <img alt=github src=https://liuguilin361.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://liuguilin361.github.io/posts style=margin-left:.25em>/posts</a><a href=https://liuguilin361.github.io/tags style=margin-left:.25em>/tags</a><a href=https://liuguilin361.github.io/projects style=margin-left:.25em>/projects</a><a href=https://liuguilin361.github.io/talks style=margin-left:.25em>/talks</a><a href=https://liuguilin361.github.io/about style=margin-left:.25em>/about</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://liuguilin361.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://liuguilin361.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://liuguilin361.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Benchmarking Caches in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-01-31</time> :: 1745 Words <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://liuguilin361.github.io/tags/rust/>rust</a>, <a class=post-tag href=https://liuguilin361.github.io/tags/performance/>performance</a> </span></div></div><section class=body><style>img{width:100%}:root.dark img{filter:invert()}</style><h1 id=preface>Preface</h1><p>I'm currently working on an Intel hypervisor (very fun project btw) and had the following problem: The hypervisor needs to be very performant (otherwise the system slows down) so I have to cache as many things as possible. But how do I do that? I know that there are some crates that provide a nice API for one-time initialized static variables. But how do they work under the hood? And are they the best solution? Let's find out!<h1 id=naive-solution>Naive Solution</h1><p>One solution would be to don't cache the value at all. This will serve as a baseline for the other solutions. We'll use the <a href=https://namazso.github.io/x86/html/CPUID.html>CPUID</a> instruction as an example value which should be cached, as I'm also using it to detect CPU features in my hypervisor. I wanted to keep the benchmark as close as possible to the real use case to not fall into any traps.<p>We can define the benchmark function as follows:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>calc_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#f07171>black_box</span><span>(x86</span><span style=color:#ed9366>::</span><span>cpuid</span><span style=color:#ed9366>::</span><span>cpuid</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#ed9366>.</span><span>eax </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u64</span><span>)
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// just don't cache anything lol
</span><span>    </span><span style=color:#f07171>calc_value</span><span>()
</span><span>}
</span></code></pre><h2 id=benchmark>Benchmark</h2><p>Let's benchmark it using <a href=https://bheisler.github.io/criterion.rs/book/>criterion</a>.<p>28ns is quite fast, but what if we have an instruction that takes much longer? What if we want to log the value or have to do heavy computations? This would slow it down a lot. Let's see if we can do better.<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/no_cache.svg><h1 id=oncecell>OnceCell</h1><p>Like any good programmer, my second solution was to use the most popular crate I could find on the web: <a href=https://crates.io/crates/once_cell>once_cell</a>. It provides a very simple API to create a lazy static variable. We'll be using the <code>calc_value</code> function from the previous example.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>once_cell</span><span style=color:#ed9366>::</span><span>sync</span><span style=color:#ed9366>::</span><span>OnceCell</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#61676ccc>: </span><span>OnceCell<</span><span style=color:#fa6e32>u64</span><span>> </span><span style=color:#ed9366>= </span><span>OnceCell</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>get_or_init</span><span>(calc_value)
</span><span>}
</span></code></pre><h2 id=how-it-s-implemented>How it's implemented</h2><p>The implementation of <code>OnceCell</code> is quite interesting because it's based on atomic operations to ensure thread safety. It has an <a href=https://doc.rust-lang.org/std/cell/struct.SyncUnsafeCell.html>unsafe cell</a> (used for interior mutability) and an <a href=https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU8.html>atomic state</a>. The state is used to ensure that the value is only initialized once.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub</span><span>(</span><span style=color:#fa6e32>crate</span><span>) </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>OnceCell</span><span>&LTT> {
</span><span>    state</span><span style=color:#61676ccc>:</span><span> AtomicU8,
</span><span>    value</span><span style=color:#61676ccc>: </span><span>UnsafeCell<</span><span style=color:#55b4d4;font-style:italic>Option</span><span>&LTT>>,
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Possible values for state:
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>INCOMPLETE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u8 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0x0</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>RUNNING</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u8 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0x1</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>const </span><span style=color:#ff8f40>COMPLETE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u8 </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0x2</span><span style=color:#61676ccc>;
</span></code></pre><p>They built a very nice and easy-to-use API on top of it which explains the popularity of the crate.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTT> </span><span style=color:#399ee6>OnceCell</span><span>&LTT> {
</span><span>    </span><span style=color:#fa6e32>const fn </span><span style=color:#f29718>new</span><span>() </span><span style=color:#61676ccc>-> </span><span>OnceCell&LTT> { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>set</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>:</span><span> T) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), T> { </span><span style=color:#ed9366>... </span><span>}
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>get</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>T> { </span><span style=color:#ed9366>... </span><span>}
</span><span>}
</span></code></pre><h2 id=benchmark-1>Benchmark</h2><p>The solution is quite straightforward, but how does it perform?<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/once_cell.svg><p>Not bad. It takes on average around 215ps to get the value. That's already a 140x speedup. But can we do better?<h1 id=lazy-static>lazy_static</h1><p>Let's check out another equally popular crate: <a href=https://crates.io/crates/lazy_static><code>lazy_static</code></a>. It provides a macro that allows us to create a lazy static variable.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>lazy_static</span><span style=color:#ed9366>::</span><span>lazy_static</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#f07171>lazy_static!</span><span>{
</span><span>        </span><span style=color:#fa6e32>static ref </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64 </span><span style=color:#ed9366>= </span><span style=color:#f07171>calc_value</span><span>()</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>CACHED_VALUE
</span><span>}
</span></code></pre><h2 id=how-it-s-implemented-1>How it's implemented</h2><p><code>lazy_static</code> uses the <a href=https://docs.rs/spin/0.9.8/spin/once/struct.Once.html><code>Once</code></a> synchronization primitive from the <a href=https://crates.io/crates/spin>spin</a> crate. The <code>Once</code> primitive can be used to call a function exactly once (as the name suggests):<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use</span><span> spin</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>START</span><span style=color:#61676ccc>: </span><span>spin</span><span style=color:#ed9366>::</span><span>Once </span><span style=color:#ed9366>= </span><span>spin</span><span style=color:#ed9366>::</span><span>Once</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#ff8f40>START</span><span style=color:#ed9366>.</span><span style=color:#f07171>call_once</span><span>(|| {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// run initialization here
</span><span>})</span><span style=color:#61676ccc>;
</span></code></pre><p>The implementation under the hood is very similar to <code>once_cell</code>. We have a status, an unsafe cell for the data and a <a href=https://doc.rust-lang.org/std/marker/struct.PhantomData.html>phantom data</a>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Once</span><span>&LTT = (), R = Spin> {
</span><span>    phantom</span><span style=color:#61676ccc>: </span><span>PhantomData&LTR>,
</span><span>    status</span><span style=color:#61676ccc>:</span><span> AtomicStatus,
</span><span>    data</span><span style=color:#61676ccc>: </span><span>UnsafeCell&LTMaybeUninit&LTT>>,
</span><span>}
</span></code></pre><p>With this primitive, one can easily implement the container for the data behind the lazy_static macro. Add some syntactic sugar and we have a very nice API.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>::</span><span>spin</span><span style=color:#ed9366>::</span><span>Once</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>Lazy</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Sync</span><span>>(Once&LTT>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Sync</span><span>> </span><span style=color:#399ee6>Lazy</span><span>&LTT> {
</span><span>    </span><span style=color:#fa6e32>pub const </span><span style=color:#ff8f40>INIT</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>Self </span><span style=color:#ed9366>=</span><span> Lazy(Once</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>INIT</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>(always)]
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>get</span><span>&LTF>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>'static </span><span style=color:#ff8f40>self</span><span>, </span><span style=color:#ff8f40>builder</span><span style=color:#61676ccc>:</span><span> F) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>T
</span><span>    </span><span style=color:#fa6e32>where
</span><span>        F</span><span style=color:#61676ccc>:</span><span> FnOnce() -> T,
</span><span>    {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>call_once</span><span>(builder)
</span><span>    }
</span><span>}
</span></code></pre><h2 id=benchmark-2>Benchmark</h2><p>Since the synchronization primitives used under the hood are so similar to <code>once_cell</code>, the performance is also very similar with 320ps on average.<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/lazy_static.svg><h1 id=atomics>Atomics</h1><p>If you look back at the code of <code>once_cell</code> and <code>lazy_static</code>, you will notice that they both use atomic operations to ensure thread safety. But what are atomic operations and how do they work? Let's find out!<h2 id=what-are-they>What are they?</h2><p>Atomics behave the same way as normal operations (read, write, add, sub, etc.) but they come with further guarantees. They ensure that the operation is executed atomically, meaning that no other thread can access the memory location at the same time. They also provide the option to specify <a href=https://en.wikipedia.org/wiki/Memory_ordering>memory ordering</a>.<h2 id=what-the-hell-is-memory-ordering>What the hell is Memory Ordering?</h2><p>Compilers and CPUs are allowed to reorder memory accesses for performance reasons (<a href="https://en.wikipedia.org/wiki/Out-of-order_execution?useskin=vector">out-of-order-execution</a>). By using Atomics, we can specify the order in which memory accesses should be executed.<p>Instruction reordering might not be an issue for simple programs, but it can lead to very subtle bugs in concurrent programs. Let's take this example (taken from the to <a href=https://marabos.nl/atomics/memory-ordering.html>Rust Atomics and Locks</a> book by Mara Bos):<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>static</span><span> X</span><span style=color:#61676ccc>:</span><span> AtomicI32 </span><span style=color:#ed9366>= </span><span>AtomicI32</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>static</span><span> Y</span><span style=color:#61676ccc>:</span><span> AtomicI32 </span><span style=color:#ed9366>= </span><span>AtomicI32</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>thread_a</span><span>() {
</span><span>    X</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>10</span><span style=color:#61676ccc>,</span><span> Relaxed)</span><span style=color:#61676ccc>;
</span><span>    Y</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>20</span><span style=color:#61676ccc>,</span><span> Relaxed)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>thread_b</span><span>() {
</span><span>    </span><span style=color:#fa6e32>let</span><span> y </span><span style=color:#ed9366>=</span><span> Y</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Relaxed)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> x </span><span style=color:#ed9366>=</span><span> X</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Relaxed)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{x} {y}</span><span style=color:#86b300>"</span><span>)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>The CPU can execute these instructions in any order. Possible outputs are:<ul><li><code>0 0</code>: Thread B reads the values before Thread A was able to write them.<li><code>10 0</code>: Thread A writes X, then Thread B reads both.<li><code>10 20</code>: Thread A writes X and Y, then Thread B reads both.<li><code>0 20</code>: Thread A writes Y before X, then Thread B reads both.</ul><p>How can this lead to issues? Let's take a look at this example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>static </span><span style=color:#ff8f40>LOCKED</span><span style=color:#61676ccc>:</span><span> AtomicBool </span><span style=color:#ed9366>= </span><span>AtomicBool</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>VALUE</span><span style=color:#61676ccc>: </span><span>UnsafeCell<</span><span style=color:#fa6e32>u64</span><span>> </span><span style=color:#ed9366>= </span><span>UnsafeCell</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>update</span><span>(</span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64</span><span>) {
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ff8f40>LOCKED</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Relaxed) {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Alternatively just spin until it's not locked
</span><span>        </span><span style=color:#fa6e32>return</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// &LT--- Thread could be scheduled here
</span><span>
</span><span>    </span><span style=color:#ff8f40>LOCKED</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>,</span><span> Relaxed)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>() </span><span style=color:#ed9366>=</span><span> value }</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ff8f40>LOCKED</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,</span><span> Relaxed)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>If two programs execute the conditional check at the same time, then they'll both try to lock and store the value. The solution: Different memory orderings.<p>In Rust, there's a non_exhaustive enum called <a href=https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html>Ordering</a> which specifies allowed orderings.<ul><li><code>Ordering::Relaxed</code>: No guarantees, can be reordered freely.<li><code>Ordering::Release</code> (store) and <code>Ordering::Acquire</code> (load): When used together, they form a lock. No memory stored after <code>Release</code> and no reads before <code>Acquire</code>. This is the most common use case for atomics. This achieves a happens-before relationship between the two threads (<code>Release</code> is always executed before <code>Acquire</code>).</ul><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>static </span><span style=color:#ff8f40>READY</span><span style=color:#61676ccc>:</span><span> AtomicBool </span><span style=color:#ed9366>= </span><span>AtomicBool</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#ff8f40>false</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>VALUE</span><span style=color:#61676ccc>:</span><span> AtomicU64 </span><span style=color:#ed9366>= </span><span>AtomicU64</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>thread_a</span><span>() {
</span><span>    </span><span style=color:#ff8f40>VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>42</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ff8f40>READY</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Release)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// Executed before `Acquire`
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>thread_b</span><span>() {
</span><span>    </span><span style=color:#fa6e32>while </span><span style=color:#ed9366>!</span><span style=color:#ff8f40>READY</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Acquire) {} </span><span style=color:#abb0b6;font-style:italic>// Executed after `Release`
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// We can now safely read the value
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Relaxed))</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><ul><li><code>Ordering::AcqRel</code> (load-with-store): Represents both <code>Acquire</code> and <code>Release</code>. Used for <code>compare_exchange</code> and other operations that do both.<li><code>Ordering::SeqCst</code>: Like Acquire/Release/AcqRel (for load, store, and load-with-store operations, respectively) but with additional guarantees.</ul><p>Atomics are a complex topic and I can't cover everything in this post. If you want to learn more about it, I can recommend the video <a href="https://www.youtube.com/watch?v=rMGWeSjctlY">Crust of Rust: Atomics and Memory Ordering</a> by Jon Gjengset and the <a href=https://marabos.nl/atomics/memory-ordering.html>Rust Atomics and Locks</a> book by Mara Bos.<h2 id=how-it-s-implemented-2>How it's implemented</h2><h3 id=compareexchange>CompareExchange</h3><p>With all the theory covered, let's try to implement a cache using <code>compare_exchange</code>. For the sake of simplicity, we'll use <code>Ordering::Relaxed</code> for all operations. This is safe because in the worst case, we'll just compute the value twice.<p>The function <code>compare_exchange</code> compares the first argument with the value in the atomic and replaces it with the second argument if they are equal. It returns a <code>Result</code> which indicates whether the value was replaced or not.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#61676ccc>:</span><span> AtomicU64 </span><span style=color:#ed9366>= </span><span>AtomicU64</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ = </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>compare_exchange</span><span>(
</span><span>        </span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#f07171>calc_value</span><span>()</span><span style=color:#61676ccc>,
</span><span>        Ordering</span><span style=color:#ed9366>::</span><span>Relaxed</span><span style=color:#61676ccc>,
</span><span>        Ordering</span><span style=color:#ed9366>::</span><span>Relaxed</span><span style=color:#61676ccc>,
</span><span>    )</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Relaxed)
</span><span>}
</span></code></pre><p>You might think: "Wait, why do we need to load the value again? We just replaced it!". The reason is that <code>compare_exchange</code> returns the old value. So we need to load it again to return it.<p>The <code>compare_exchange</code> function is usually used for Mutexes to check whether the lock is already taken and then acquire it. So it might not be the ideal solution, but we'll see how it performs in the benchmark.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>update_locked_value</span><span>(</span><span style=color:#ff8f40>value</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64</span><span>) {
</span><span>    </span><span style=color:#fa6e32>while </span><span style=color:#ed9366>!</span><span style=color:#ff8f40>LOCKED</span><span style=color:#ed9366>.</span><span style=color:#f07171>compare_exchange</span><span>(
</span><span>        </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>,
</span><span>        </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>, 
</span><span>        Ordering</span><span style=color:#ed9366>::</span><span>Acquire</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Relaxed
</span><span>    )</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_ok</span><span>() {
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Optimization: yield
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Update the value
</span><span>    </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>get</span><span>() </span><span style=color:#ed9366>=</span><span> value }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ff8f40>LOCKED</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(</span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Release)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=load-store>Load/Store</h3><p>Since we need a load operation anyway, we can also use <code>load</code> and <code>store</code> instead of <code>compare_exchange</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#fa6e32>static </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#61676ccc>:</span><span> AtomicU64 </span><span style=color:#ed9366>= </span><span>AtomicU64</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> value </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>load</span><span>(Ordering</span><span style=color:#ed9366>::</span><span>Acquire)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if</span><span> value </span><span style=color:#ed9366>!= </span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX </span><span>{
</span><span>        </span><span style=color:#fa6e32>return</span><span> value</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> value </span><span style=color:#ed9366>= </span><span style=color:#f07171>calc_value</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#ed9366>.</span><span style=color:#f07171>store</span><span>(value</span><span style=color:#61676ccc>, </span><span>Ordering</span><span style=color:#ed9366>::</span><span>Release)</span><span style=color:#61676ccc>;
</span><span>    value
</span><span>}
</span></code></pre><h2 id=benchmark-3>Benchmark</h2><p>Turns out that <code>compare_exchange</code> is a very expensive operation. The retrieval of the cached value takes 34ns on average, which is significantly slower than the previous solutions. It is even slower than the naive solution without caching which took 28ns on average.<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/compare_exchange.svg><p>In contrast, the load/store solution is very fast with 230ps on average. This is because the CPU can optimize the load/store operations very well (more on that later).<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/load_store.svg><h1 id=static-mutability>Static Mutability</h1><p>Let's ignore everything we learned about atomics and memory orderings and just use a static mutable variable. This is not thread-safe, but we'll just ignore that for now. This is not an issue for my use case, because I don't have many threads running at the same time when the value is initialized.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>cached_value</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u64 </span><span>{
</span><span>    </span><span style=color:#fa6e32>static mut </span><span style=color:#ff8f40>CACHED_VALUE</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64 </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> value </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#ff8f40>CACHED_VALUE </span><span>}</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if</span><span> value </span><span style=color:#ed9366>!= </span><span style=color:#fa6e32>u64</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>MAX </span><span>{
</span><span>        </span><span style=color:#fa6e32>return</span><span> value</span><span style=color:#61676ccc>;
</span><span>    } 
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> value </span><span style=color:#ed9366>= </span><span style=color:#f07171>calc_value</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>unsafe </span><span>{ </span><span style=color:#ff8f40>CACHED_VALUE </span><span style=color:#ed9366>=</span><span> value }</span><span style=color:#61676ccc>;
</span><span>    value
</span><span>}
</span></code></pre><h2 id=benchmark-4>Benchmark</h2><p>Turns out that this solution generates the same assembly instructions as the load/store solution. Thus the performance is also the same at 230ps on average.<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/unsafe_static.svg><h1 id=why-is-load-store-the-same-as-unsafe-static>Why is load/store the same as unsafe-static?</h1><p>On x86 CPUs, all memory operations have the ordering of <a href=https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.AcqRel><code>AcqRel</code></a> so we don't need to specify it explicitly. The compiler also knows this, so all atomic operations can be optimized to much faster <code>mov</code> instructions.<p>Comparing the code on <a href=https://rust.godbolt.org/z/1rPb1aT6o>Compiler Explorer</a>, we can see that there's absolutely no difference between the two solutions.<pre class=language-asm data-lang=asm style=color:#61676c;background-color:#fafafa><code class=language-asm data-lang=asm><span style=color:#f29718>example::unsafe_static:
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#ff8f40>rax</span><span>, </span><span style=color:#f07171>qword ptr </span><span>[</span><span style=color:#ff8f40>rip </span><span>+ </span><span style=color:#f29718>example::unsafe_static::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span>]
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>cmp     </span><span style=color:#ff8f40>rax</span><span>, -</span><span style=color:#ff8f40>1
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>je      </span><span style=color:#f29718>.LBB0_1
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>ret
</span><span style=color:#f29718>.LBB0_1:
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>push    </span><span style=color:#ff8f40>rax
</span><span>
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>cpuid
</span><span>
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#ff8f40>eax</span><span>, </span><span style=color:#ff8f40>eax
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#f07171>qword ptr </span><span>[</span><span style=color:#ff8f40>rip </span><span>+ </span><span style=color:#f29718>example::unsafe_static::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span>], </span><span style=color:#ff8f40>rax
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>add     </span><span style=color:#ff8f40>rsp</span><span>, </span><span style=color:#ff8f40>8
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>ret
</span><span>
</span><span style=color:#f29718>example::unsafe_static::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span style=color:#f29718>:
</span><span style=color:#f29718>    .quad   </span><span>-</span><span style=color:#ff8f40>1
</span></code></pre><pre class=language-asm data-lang=asm style=color:#61676c;background-color:#fafafa><code class=language-asm data-lang=asm><span style=color:#f29718>example::atomic_load_store:
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#ff8f40>rax</span><span>, </span><span style=color:#f07171>qword ptr </span><span>[</span><span style=color:#ff8f40>rip </span><span>+ </span><span style=color:#f29718>example::atomic_load_store::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span>]
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>test    </span><span style=color:#ff8f40>rax</span><span>, </span><span style=color:#ff8f40>rax
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>je      </span><span style=color:#f29718>.LBB1_1
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>ret
</span><span style=color:#f29718>.LBB1_1:
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>push    </span><span style=color:#ff8f40>rax
</span><span>
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>cpuid
</span><span>
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#ff8f40>eax</span><span>, </span><span style=color:#ff8f40>eax
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>mov     </span><span style=color:#f07171>qword ptr </span><span>[</span><span style=color:#ff8f40>rip </span><span>+ </span><span style=color:#f29718>example::atomic_load_store::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span>], </span><span style=color:#ff8f40>rax
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>add     </span><span style=color:#ff8f40>rsp</span><span>, </span><span style=color:#ff8f40>8
</span><span style=color:#f29718>    </span><span style=color:#fa6e32>ret
</span><span>
</span><span style=color:#f29718>example::atomic_load_store::CACHED_VALUE.</span><span style=color:#ff8f40>0</span><span style=color:#f29718>:
</span><span style=color:#f29718>    .quad   </span><span style=color:#ff8f40>0
</span></code></pre><h1 id=comparing-all-solutions>Comparing all solutions</h1><p>Turns out, it doesn't matter which crate or option we choose as long as we don't use the <code>compare_exchange</code> implementation. I'd suggest using <code>once_cell</code> or <code>lazy_static</code> because they provide a nice API and are easy to use.<p>However, one could benefit from the unsafe static approach when writing code for a platform that has a different default memory ordering (RISC-V or ARM).<p><img alt src=https://liuguilin361.github.io/posts/cache-bench/./svgs/violin.svg><p>I thought there would be a bigger difference between the different solutions. But <code>once_cell</code>, <code>lazy_static</code> and <code>load-store</code> are almost equally as fast.<pre style=color:#61676c;background-color:#fafafa><code><span>cached-value/no cache   time:   [27.438 ns 27.823 ns 28.338 ns]
</span><span>cached-value/once cell  time:   [216.02 ps 216.82 ps 217.75 ps]
</span><span>cached-value/lazy static
</span><span>                        time:   [320.65 ps 321.75 ps 323.15 ps]
</span><span>cached-value/compare exchange
</span><span>                        time:   [34.701 ns 34.811 ns 34.953 ns]
</span><span>cached-value/load store time:   [234.55 ps 235.03 ps 235.62 ps]
</span><span>cached-value/unsafe static
</span><span>                        time:   [227.99 ps 228.74 ps 229.73 ps]
</span></code></pre><p>I also used the <a href=https://crates.io/crates/microbench><code>microbench</code></a> crate to get a better overview of the performance. The results are similar to the ones from <a href=https://crates.io/crates/criterion><code>criterion</code></a>:<pre style=color:#61676c;background-color:#fafafa><code><span>no cache (5.0s) ...                       27.115 ns/iter (0.999 R²)
</span><span>once cell (5.0s) ...                       0.221 ns/iter (0.999 R²)
</span><span>lazy static (5.0s) ...                     0.474 ns/iter (1.000 R²)
</span><span>compare exchange (5.0s) ...               34.937 ns/iter (0.999 R²)
</span><span>load store (5.0s) ...                      0.236 ns/iter (1.000 R²)
</span><span>unsafe static (5.0s) ...                   0.226 ns/iter (1.000 R²)
</span></code></pre><p>You can find the benchmarks <a href=https://github.com/not-matthias/cache-bench>here</a>.<h1 id=conclusion>Conclusion</h1><p>Here are some takeaways from this benchmark:<ul><li><strong>Compare against dumb solution</strong>: It's really easy to implement and can reveal some interesting insights (like the <code>compare_exchange</code> solution being slower than the dumb solution).<li><strong>Keep it close to the real world</strong>: Don't try to benchmark the calculation of <code>2 + 2</code>, but rather something close to your use case. In my case, this was the CPUID instruction.<li><strong>Avoid premature optimizations</strong>: Most of the time, you won't benefit from reducing the time from 28ns to 200ps, even though it sounds impressive. Don't optimize prematurely, and don't bother optimizing one-time costs. The gist <a href=https://gist.github.com/kvark/f067ba974446f7c5ce5bd544fe370186>Achieving warp speed with Rust</a> has very useful tips for benchmarking. <ul><li>However, I believe it was worth it in my case because I was actually using <code>compare_exchange</code>. It's always useful to have benchmarks to back up your decisions.</ul><li>Use <code>once_cell</code> or <code>lazy_static</code></ul><hr><p>I really enjoyed working on this benchmark. I was able to refresh my knowledge about memory orderings and atomics. If you have any comments, feel free to reach out to me.<p>As always, thanks for reading!</section></article></main></div>