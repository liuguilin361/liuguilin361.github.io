<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://liuguilin361.github.io name=base><title>
         Writing a kernel driver with Rust
        
    </title><meta content="Writing a kernel driver with Rust" property=og:title><link href=https://liuguilin361.github.io/fonts.css rel=stylesheet><script data-host-url=https://api-gateway.umami.dev/ data-website-id=74344cd8-1e87-4c38-8acd-f96049b8f07e defer src=/js/imamu.js></script><script async data-goatcounter=https://not-matthias.goatcounter.com/count src=https://liuguilin361.github.io/js/count.js></script><noscript><img src="https://not-matthias.goatcounter.com//count?p=/posts/kernel-driver-with-rust/&t=Writing a kernel driver with Rust"></noscript><link title="liuguilin's blog" href=https://liuguilin361.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://liuguilin361.github.io/theme/light.css rel=stylesheet><link href=https://liuguilin361.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://liuguilin361.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://liuguilin361.github.io/main.css media=screen rel=stylesheet><script src="https://liuguilin361.github.io/search_index.en.js?h=b0e86fa6164ec2b23997" defer></script><script src="https://liuguilin361.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://liuguilin361.github.io>liuguilin's blog</a><div class=socials><a class=social href=https://twitter.com/not_matthias rel=me> <img alt=twitter src=https://liuguilin361.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/liuguilin361/ rel=me> <img alt=github src=https://liuguilin361.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://liuguilin361.github.io/posts style=margin-left:.25em>/posts</a><a href=https://liuguilin361.github.io/tags style=margin-left:.25em>/tags</a><a href=https://liuguilin361.github.io/projects style=margin-left:.25em>/projects</a><a href=https://liuguilin361.github.io/talks style=margin-left:.25em>/talks</a><a href=https://liuguilin361.github.io/about style=margin-left:.25em>/about</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://liuguilin361.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://liuguilin361.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://liuguilin361.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Writing a kernel driver with Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2020-07-15</time> :: Updated on <time>2022-08-16</time> :: 2453 Words <span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://liuguilin361.github.io/tags/windows-kernel/>windows kernel</a>, <a class=post-tag href=https://liuguilin361.github.io/tags/rust/>rust</a> </span></div></div><section class=body><p><strong>Update</strong>: A few things have changed since I wrote this blog post. For more information, visit <a href=http://not-matthias.github.io/posts/kernel-driver-with-rust-2022/> Kernel Driver with Rust in 2022</a>.<h1 id=preface>Preface</h1><p>I read the official <a href=https://doc.rust-lang.org/book/>Rust book</a> already in the end of 2019 but never had a project idea. That's why I decided to rewrite one of my already existing C++ projects. A few months after I started I already gained lots of experience and began to wonder whether it's possible to rewrite my Windows Kernel Drivers in Rust. A quick search lead me to many unanswered questions and two Github repositories. One of these repositories is <a href=https://github.com/pravic/winapi-kmd-rs>winapi-kmd-rs</a> which is unfortunately really complicated and outdated. I almost gave up until I stumbled upon <a href=https://github.com/Trantect/win_driver_example>win_driver_example</a> which made me realize that a lot has changed and that it's not even that hard. This post summarize what went wrong and what I learned.<h1 id=project-setup>Project Setup</h1><p>I'll keep this example project simple but I recommend creating a <a href=https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html>workspace</a> so you don't end up having one big project. I made this mistake and had to break it into multiple crates. I sat down and thought of a folder structure and split the project into 21 different crates. This might sound a bit overkill, but I really like having a crate for only one task. For example, I have <code>log</code>, <code>string</code>, <code>nt</code> and <code>km-alloc</code> crates which makes refactoring a lot easier and allows you to reuse those crates in other projects.<p>With that in mind, let's get started with a demo project. The first thing we need to do is setup our driver project with the command <code>cargo new --bin driver</code> and open it in the editor of your choice.<p>Rust provides lots of abstractions in the <a href=https://doc.rust-lang.org/std/>standard library</a> which cannot be used in the kernel because it uses the Windows API behind the scenes. Thanks to the awesome language design, we can remove the standard library by specifying the <code>#![no_std]</code> attribute in <code>main.rs</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#!</span><span>[</span><span style=color:#f29718>no_std</span><span>]
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {}
</span></code></pre><p>However, if you try to build the project, you'll get some errors:<pre style=color:#61676c;background-color:#fafafa><code><span>D:\driver>cargo b
</span><span>   Compiling driver v0.1.0 (D:\driver)
</span><span>
</span><span>error: `#[panic_handler]` function required, but not found
</span><span>error: language item required, but not found: `eh_personality`
</span><span>error: aborting due to 2 previous errors
</span><span>error: could not compile `driver`.
</span></code></pre><p>It turns out, the standard library actually does all these things behind the scenes. So let's implement it ourself. The second error can be fixed quite easily by modifying the build profile. An explanation for this error can be found <a href=https://stackoverflow.com/a/48984171>here</a>.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[</span><span style=color:#399ee6>profile</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>dev</span><span>]
</span><span style=color:#399ee6>panic </span><span>= </span><span style=color:#86b300>"abort"
</span></code></pre><p>Now lets fix the first error. Just looking at the attribute name says a lot. When our program <a href=https://doc.rust-lang.org/std/macro.panic.html>panics</a>, an unrecoverable error occurs. Rust will unwind the stack, clean up the resources and show a nice error message. But in the kernel, there's no console and thus we have to handle these unrecoverable errors ourself.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#!</span><span>[</span><span style=color:#f29718>no_std</span><span>]
</span><span>
</span><span style=color:#fa6e32>use </span><span>core</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>PanicInfo</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>panic_handler</span><span>]
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>panic</span><span>(</span><span style=color:#ff8f40>_info</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>PanicInfo) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>! </span><span>{
</span><span>    </span><span style=color:#fa6e32>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>main</span><span>() {}
</span></code></pre><p>You can try to build the project again but it won't work yet, because I didn't tell you everything. We are not compiling a binary, but actually a library. A dynamic link library (<code>.dll</code>) to be more precise. Rename your <code>main.rs</code> to <code>lib.rs</code> and add the following to your <code>Cargo.toml</code>:<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[</span><span style=color:#399ee6>lib</span><span>]
</span><span style=color:#399ee6>path </span><span>= </span><span style=color:#86b300>"src/lib.rs"
</span><span style=color:#399ee6>crate-type </span><span>= [</span><span style=color:#86b300>"cdylib"</span><span>]
</span></code></pre><p>When we try to build the project again we get a different error: <code>LINK : error LNK2001: unresolved external symbol _DllMainCRTStartup</code>. When Rust calls the Visual Studio linker behind the scenes, it passes the parameters that would normally be used to compile a dll. Luckily, we can override those and define our custom entry point. For that, we need to create a file <code>.cargo/config</code> in our project.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[</span><span style=color:#399ee6>build</span><span>]
</span><span style=color:#399ee6>target </span><span>= </span><span style=color:#86b300>"x86_64-pc-windows-msvc"
</span><span>
</span><span style=color:#399ee6>rustflags </span><span>= [
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Pre Link Args
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/NOLOGO"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/NXCOMPAT"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/NODEFAULTLIB"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/SUBSYSTEM:NATIVE"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/DRIVER"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/DYNAMICBASE"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-Z"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"pre-link-arg=/MANIFEST:NO"</span><span style=color:#61676ccc>,
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Post Link Args
</span><span>    </span><span style=color:#86b300>"-C"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"link-arg=/OPT:REF,ICF"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-C"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"link-arg=/ENTRY:driver_entry"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-C"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"link-arg=/MERGE:.edata=.rdata"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-C"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"link-arg=/MERGE:.rustc=.data"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"-C"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"link-arg=/INTEGRITYCHECK"
</span><span>]
</span></code></pre><p>These options should be relatively self-explanatory. The most important one is the <code>/ENTRY</code> option, where we can set our custom program entry point. If you don't understand some of these, you can look them up in the <a href=https://docs.microsoft.com/en-us/cpp/build/reference/linker-options>official documentation</a>. The <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/wdf/driverentry-for-kmdf-drivers>entry point</a> would normally have also two parameters but I decided to leave them for the sake of simplicity.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>no_mangle</span><span>]
</span><span style=color:#fa6e32>pub extern </span><span style=color:#86b300>"system" </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>driver_entry</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u32 </span><span>{
</span><span>    </span><span style=color:#ff8f40>0 </span><span style=color:#abb0b6;font-style:italic>/* STATUS_SUCCESS */
</span><span>}
</span></code></pre><p>If we try to build our project again, it finally works! You can find the output file in the <code>driver\target\x86_64-pc-windows-msvc\debug</code> folder. Remember when I told you that we actually create a library? Well, unfortunately Rust has no option to rename the file extension to <code>.sys</code>. More information on how this restriction can be circumvented can be found below.<p>If that's a big deal for you, you can take a look at <a href=https://github.com/rust-osdev/cargo-xbuild>cargo-xbuild</a>. I also started my project with it but eventually migrated away from it, because a change in <code>cargo</code> caused an <a href=https://github.com/rust-lang/cargo/issues/8308>assertion to fail</a>. The usage is pretty straightforward and can also be found in the <a href=https://github.com/Trantect/win_driver_example>win_driver_example</a> repository.<h1 id=linker-settings>Linker Settings</h1><p>If you try to define and call kernel functions with our current project, it won't work because the linker can't find the libraries that define those functions. In order to get that to work, we need to extend the linker search path. Of course we could just hardcode the path in our application, but that's not really idiomatic. It turns out that <a href=https://github.com/Trantect>Trantect</a> did that already in one of their projects. If you take a look at the <a href=https://github.com/Trantect/win-kmd-alloc/blob/master/build.rs>build script</a>, you'll see that it searches the Registry to find the path to the kernel libraries (in my case <code>C:\Program Files (x86)\Windows Kits\10\lib\10.0.18362.0\km</code>). Here's the code that is responsible for finding and setting the path.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> windows_kits_dir </span><span style=color:#ed9366>= </span><span style=color:#f07171>get_windows_kits_dir</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> km_dir </span><span style=color:#ed9366>= </span><span style=color:#f07171>get_km_dir</span><span>(</span><span style=color:#ed9366>&</span><span>windows_kits_dir)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> target </span><span style=color:#ed9366>= </span><span style=color:#f07171>var</span><span>(</span><span style=color:#86b300>"TARGET"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> arch </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> target</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(</span><span style=color:#86b300>"x86_64"</span><span>) {
</span><span>    </span><span style=color:#86b300>"x64"
</span><span>} </span><span style=color:#fa6e32>else if</span><span> target</span><span style=color:#ed9366>.</span><span style=color:#f07171>contains</span><span>(</span><span style=color:#86b300>"i686"</span><span>) {
</span><span>    </span><span style=color:#86b300>"x86"
</span><span>} </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"Only support x86_64 and i686!"</span><span>)</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> lib_dir </span><span style=color:#ed9366>=</span><span> km_dir</span><span style=color:#ed9366>.</span><span style=color:#f07171>join</span><span>(arch)</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>println!</span><span>(
</span><span>    </span><span style=color:#86b300>"cargo:rustc-link-search=native=</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,
</span><span>    lib_dir</span><span style=color:#ed9366>.</span><span style=color:#f07171>to_str</span><span>()</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>()
</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><h1 id=interacting-with-the-kernel>Interacting with the kernel</h1><p>Alright, we can run our Rust driver in the kernel, but that's basically useless since Rust doesn't have bindings to the kernel library. Luckily, Rust makes it easy to <a href=https://rust-embedded.github.io/book/interoperability/c-with-rust.html>create bindings to non-rust code</a>.<p>Some people already decided to create bindings, but they are very limited and do not cover undocumented functions. The project with the best bindings is a fork of the official WinAPI rust bindings and has a <code>feature/km</code> branch. It can be found <a href=https://github.com/Trantect/winapi-rs/tree/feature/km>here</a>.<p>However, as I said before, sometimes there's no bindings available and we have to do it ourselves. Let's explore this with an example. Let's say you want to check if an address is valid. We can use the function <code>MmIsAddressValid</code> which checks for page faults on read or write operations.<p>The first thing we need to do is create the definition of our function.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>PVOID </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>*mut </span><span>core</span><span style=color:#ed9366>::</span><span>ffi</span><span style=color:#ed9366>::</span><span style=color:#fa6e32>c_void</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>extern </span><span style=color:#86b300>"system" </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>MmIsAddressValid</span><span>(</span><span style=color:#ff8f40>VirtualAddress</span><span style=color:#61676ccc>:</span><span> PVOID) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>bool</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>As you can see, I also created a type alias <code>PVOID</code>. Do you need that? No, but I want to keep the function definitions as close as possible to the original to reduce the number of errors when copy-pasting the definitions from MSDN.<p>Alright, how can we use this function? It's simple. Just call it with whatever parameters you'd like.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> is_valid </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ MmIsAddressValid(</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>as _</span><span>) }</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"MmIsAddressValid(0) returned </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> is_valid)</span><span style=color:#61676ccc>;
</span></code></pre><p>If you try to run this, it'll not work because <code>println!()</code> is a macro defined in the standard library. So let's create our own custom log macro.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub use </span><span>winapi</span><span style=color:#ed9366>::</span><span>km</span><span style=color:#ed9366>::</span><span>wdm</span><span style=color:#ed9366>::</span><span>DbgPrint</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>macro_export</span><span>]
</span><span style=color:#f07171>macro_rules! </span><span style=color:#399ee6>log </span><span>{
</span><span>    ($string: expr) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>            $crate</span><span style=color:#ed9366>::</span><span>DbgPrint(</span><span style=color:#f07171>concat!</span><span>(</span><span style=color:#86b300>"[>] "</span><span style=color:#61676ccc>, </span><span>$string</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>())
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    ($string: expr, </span><span style=color:#ed9366>$</span><span>(</span><span style=color:#ff8f40>$x</span><span style=color:#61676ccc>:</span><span style=color:#fa6e32>tt</span><span>)</span><span style=color:#ed9366>*</span><span>) </span><span style=color:#ed9366>=> </span><span>{
</span><span>        </span><span style=color:#fa6e32>unsafe </span><span>{
</span><span>            $crate</span><span style=color:#ed9366>::</span><span>DbgPrint(</span><span style=color:#f07171>concat!</span><span>(</span><span style=color:#86b300>"[>] "</span><span style=color:#61676ccc>, </span><span>$string</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>"</span><span>)</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>$</span><span>($x)</span><span style=color:#ed9366>*</span><span>)
</span><span>        }
</span><span>    }</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>This implementation is pretty straightforward. I decided not to create the definition for the function because the WinAPI crate already <a href=https://github.com/Trantect/winapi-rs/blob/feature/km/src/km/wdm.rs#L771-L774>defines it</a>. Moreover, I also added a prefix to all the messages. We also need to add the null byte (<code>\0</code>) so that the kernel knows where our string ends. The parameter for this function is just <code>*const u8</code> which is another way of saying "please give me a pointer to character array a.k.a. string" so we have to use the <code>.as_ptr()</code> function.<p>After releasing this article, <a href=https://www.reddit.com/user/daniel5151/>daniel5151</a> pointed out that this macro can be dangerous when used incorrectly. If you want to know more, check out his <a href="https://www.reddit.com/r/rust/comments/hrwyl8/writing_a_kernel_driver_with_rust/fy7fnyw/?context=3">comment</a> on Reddit.<p>If you have worked with drivers before, you'll certainly know that you don't pass ANSI strings to functions. Windows decided to use the 16-bit character alternative: Unicode strings. Why would they do that? Well, as you probably know ANSI strings have 8 bits per character. So we can have 2^8 (255) different characters which is isn't that much. A single UNICODE character is 16 bits and can be one of 2^16 (65536) characters. Fun fact: It turns out that some people even <a href=http://klingon.wiki/En/Unicode>proposed to add Klingon</a>.<p>So if we cannot pass ANSI strings, can we convert them? Of course we can, but it's a little tedious. The hard part is converting the 8-bit characters to 16-bit characters. I tried it multiple times but ended up using a crate for that: <a href=https://github.com/CasualX/obfstr>obfstr</a>. I'm just passing the wide string (<code>wchar *</code>) via the <code>obfstr::wide!()</code> macro and create the <code>UNICODE_STRING</code> structure with it.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>winapi</span><span style=color:#ed9366>::</span><span>shared</span><span style=color:#ed9366>::</span><span>ntdef</span><span style=color:#ed9366>::</span><span style=color:#ff8f40>UNICODE_STRING</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>create_unicode_string</span><span>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>[</span><span style=color:#fa6e32>u16</span><span>]) </span><span style=color:#61676ccc>-></span><span> UNICODE_STRING {
</span><span>    </span><span style=color:#fa6e32>let</span><span> len </span><span style=color:#ed9366>=</span><span> s</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> n </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>if</span><span> len </span><span style=color:#ed9366>> </span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>&&</span><span> s[len </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>] </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0 </span><span>{ len </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1 </span><span>} </span><span style=color:#fa6e32>else </span><span>{ len }</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#ff8f40>UNICODE_STRING </span><span>{
</span><span>        Length</span><span style=color:#61676ccc>: </span><span>(n </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u16</span><span style=color:#61676ccc>,
</span><span>        MaximumLength</span><span style=color:#61676ccc>: </span><span>(len </span><span style=color:#ed9366>* </span><span style=color:#ff8f40>2</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u16</span><span style=color:#61676ccc>,
</span><span>        Buffer</span><span style=color:#61676ccc>:</span><span> s</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ptr</span><span>() </span><span style=color:#ed9366>as _</span><span style=color:#61676ccc>,
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let</span><span> string </span><span style=color:#ed9366>= </span><span style=color:#f07171>create_unicode_string</span><span>(obfstr</span><span style=color:#ed9366>::</span><span>wide</span><span style=color:#ed9366>!</span><span>(</span><span style=color:#86b300>"Hello World!</span><span style=color:#4cbf99>\0</span><span style=color:#86b300>"</span><span>))</span><span style=color:#61676ccc>;
</span></code></pre><p>Alright, let's go back to our example. We have finally everything that is needed to run it. We only need to adjust the <a href=https://docs.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions>format specification syntax</a> and we are good to go.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> is_valid </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ MmIsAddressValid(</span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>as _</span><span>) }</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#f07171>log!</span><span>(</span><span style=color:#86b300>"MmIsAddressValid(0) returned %i"</span><span style=color:#61676ccc>,</span><span> is_valid </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u64</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>Now that we covered the basics, let's explore the advantages of Rust. The function <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupprocessbyprocessid>PsLookupProcessByProcessId</a> is used to get a pointer to the <code>EPROCESS</code> structure, but it also needs to be cleaned up using <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obdereferenceobject>ObfDereferenceObject</a>. If you use C you'd have to do that every time you want to return from the function.<pre class=language-c++ data-lang=c++ style=color:#61676c;background-color:#fafafa><code class=language-c++ data-lang=c++><span style=color:#fa6e32>bool </span><span style=color:#f29718>do_something</span><span>(</span><span style=color:#55b4d4;font-style:italic>HANDLE </span><span style=color:#ff8f40>process_id</span><span>) {
</span><span>    PEPROCESS process </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>nullptr</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span style=color:#f29718>NT_SUCCESS</span><span>(</span><span style=color:#f29718>PsLookupProcessByProcessId</span><span>(process_id</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>process)) {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>if </span><span>(some_condition) {
</span><span>        </span><span style=color:#f29718>ObDereferenceObject</span><span>(process)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>if </span><span>(some_condition) {
</span><span>        </span><span style=color:#f29718>ObDereferenceObject</span><span>(process)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>false</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#f29718>ObDereferenceObject</span><span>(process)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>true</span><span style=color:#61676ccc>;   
</span><span>}
</span></code></pre><p>In Rust, you can define a wrapper structure and organize everything nicely together. You can easily extend this structure and for example add a function to get the base address but that's out of scope of this post.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Process </span><span>{
</span><span>    process</span><span style=color:#61676ccc>:</span><span> PEPROCESS,
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>Process </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>by_id</span><span>(</span><span style=color:#ff8f40>process_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#fa6e32>Self</span><span>> {
</span><span>        </span><span style=color:#fa6e32>let mut</span><span> process </span><span style=color:#ed9366>= </span><span>core</span><span style=color:#ed9366>::</span><span>ptr</span><span style=color:#ed9366>::</span><span>null_mut()</span><span style=color:#61676ccc>;
</span><span>
</span><span>        </span><span style=color:#fa6e32>let</span><span> status </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>unsafe </span><span>{ PsLookupProcessByProcessId(process_id </span><span style=color:#ed9366>as _</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> process) }</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ff8f40>NT_SUCCESS</span><span>(status) {
</span><span>            </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#fa6e32>Self </span><span>{ process })
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Now comes the important part: We can use the <a href=https://doc.rust-lang.org/stable/rust-by-example/trait/drop.html>Drop</a> trait to automatically clean up the resources when the object goes out of scope.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>Drop </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Process </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>drop</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) {
</span><span>        </span><span style=color:#fa6e32>if </span><span style=color:#ed9366>!</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>process</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_null</span><span>() {
</span><span>            </span><span style=color:#fa6e32>unsafe </span><span>{ ObfDereferenceObject(</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>process </span><span style=color:#ed9366>as _</span><span>) }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This allows us to write the same code and we don't even have to care about cleaning up. We can even exit early if the process couldn't be found. Isn't it amazing?<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>do_something</span><span>(</span><span style=color:#ff8f40>process_id</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u64</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><()> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> process </span><span style=color:#ed9366>= </span><span>Process</span><span style=color:#ed9366>::</span><span>by_id(process_id)</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>if </span><span>(some_condition) {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    
</span><span>    </span><span style=color:#fa6e32>if </span><span>(some_condition) {
</span><span>        </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(())</span><span style=color:#61676ccc>;   
</span><span>}
</span></code></pre><h1 id=run-and-sign>Run and sign</h1><p>So we finished our driver but how do we run it? There's multiple ways. For example, you can enable <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option>testsigning mode</a> by running <code>bcdedit.exe -set testsigning on</code> (requires Administrator privileges). After that, you need to sign your driver with a self-signed certificate. Visual Studio does this behind the scenes if you write a driver in C++ or C. We are going to use a tool called <a href=https://github.com/sagiegurari/cargo-make>cargo-make</a> to automate this task. After installing it with <code>cargo install --force cargo-make</code> you have to create a file called <code>Makefile.toml</code> with the following content.<pre class=language-toml data-lang=toml style=color:#61676c;background-color:#fafafa><code class=language-toml data-lang=toml><span>[</span><span style=color:#399ee6>env</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>development</span><span>]
</span><span style=color:#399ee6>TARGET_PATH </span><span>= </span><span style=color:#86b300>"target/x86_64-pc-windows-msvc/debug"
</span><span>
</span><span>[</span><span style=color:#399ee6>env</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>production</span><span>]
</span><span style=color:#399ee6>TARGET_PATH </span><span>= </span><span style=color:#86b300>"target/x86_64-pc-windows-msvc/release"
</span><span style=color:#399ee6>BUILD_FLAGS </span><span>= </span><span style=color:#86b300>"--release"
</span><span>
</span><span>[</span><span style=color:#399ee6>tasks</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>build-driver</span><span>]
</span><span style=color:#399ee6>script </span><span>= [
</span><span>    </span><span style=color:#86b300>"cargo b %BUILD_FLAGS%"
</span><span>]
</span><span>
</span><span>[</span><span style=color:#399ee6>tasks</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>rename</span><span>]
</span><span style=color:#399ee6>ignore_errors </span><span>= </span><span style=color:#ff8f40>true
</span><span style=color:#399ee6>script </span><span>= [
</span><span>    </span><span style=color:#86b300>"cd %TARGET_PATH%"</span><span style=color:#61676ccc>,
</span><span>    </span><span style=color:#86b300>"rename driver.dll driver.sys"</span><span style=color:#61676ccc>,
</span><span>]
</span><span>
</span><span>[</span><span style=color:#399ee6>tasks</span><span style=color:#61676ccc>.</span><span style=color:#399ee6>sign</span><span>]
</span><span style=color:#399ee6>dependencies </span><span>= [</span><span style=color:#86b300>"build-driver"</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"rename"</span><span>]
</span><span style=color:#399ee6>script </span><span>= [
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Load the Visual Studio Developer environment
</span><span>    </span><span style=color:#86b300>"call </span><span style=color:#4cbf99>\"</span><span style=color:#86b300>%ProgramFiles(x86)%</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>Microsoft Visual Studio</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>2019</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>Community</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>VC</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>Auxiliary</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>Build</span><span style=color:#4cbf99>\\</span><span style=color:#86b300>vcvars64.bat</span><span style=color:#4cbf99>\"</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Create a self signed certificate (only if not already done)
</span><span>    </span><span style=color:#86b300>"if not exist DriverCertificate.cer ( makecert -r -pe -ss PrivateCertStore -n CN=DriverCertificate DriverCertificate.cer ) else ( echo Certificate already exists. )"</span><span style=color:#61676ccc>,
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic># Sign the driver
</span><span>    </span><span style=color:#86b300>"signtool sign /a /v /s PrivateCertStore /n DriverCertificate /t http://timestamp.digicert.com %TARGET_PATH%/driver.sys"
</span><span>]
</span></code></pre><p>We defined three tasks:<ul><li><strong>build-driver</strong>: Builds the project either in debug or release mode.<li><strong>rename</strong>: Renames the <code>.dll</code> to <code>.sys</code>. We also specify <code>ignore_errors</code> just in case the file has already been renamed.<li><strong>sign</strong>: Creates a certificate (if not already done) and signs the driver. This task depends on the two previous steps <code>build-driver</code> and <code>rename</code>.</ul><p>After running <code>cargo make sign</code> or <code>cargo make sign --profile production</code> you can load the driver either from the command line or via the <a href="http://www.osronline.com/article.cfm%5Earticle=157.htm">OSR Driver Loader</a>. You can view the <code>DbgPrint</code> output with <a href=https://docs.microsoft.com/en-us/sysinternals/downloads/debugview>DebugView</a>.<p>There's also various other ways of getting access to the kernel. Almost all of them require vulnerable drivers which can be abused to allocate kernel memory and call kernel functions. Widely known projects utilizing this technique are <a href=https://github.com/hfiref0x/TDL>TDL</a>, <a href=https://github.com/not-wlan/drvmap>drvmap</a>, <a href=https://github.com/z175/kdmapper>kdmapper</a> and many more. Because these projects are abusing vulnerabilities, loading your driver is not safe and might cause your computer to bluescreen.<h1 id=mistakes-errors-and-problems>Mistakes, errors and problems</h1><h3 id=wrong-data-types>Wrong data types</h3><p>Rewriting structures in Rust can often be complicated and a lot of effort because Microsoft uses so many aliases for their types. That's why you have to be careful to choose the correct data types. I ended up writing a driver in C++ that just prints the size of a specific structure and compared it to be sure that I didn't mess it up.<h3 id=no-official-bindings>No official bindings</h3><p><a href=https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/>Microsoft is certainly interested in using Rust for Safe Systems Programming</a> and has recently released <a href=https://github.com/microsoft/winrt-rs>Rust bindings for C++/WinRT</a>. The <a href=https://github.com/retep998/winapi-rs>WinAPI Rust bindings</a> are still managed by the community and do not include the Windows Kernel API. There's a <a href=https://github.com/Trantect/winapi-rs/tree/feature/km>fork</a> available that started creating bindings but it's far from perfect. I wish to see more progress in the development of these bindings from Microsoft.<h3 id=lack-of-nostd-crates>Lack of nostd crates</h3><p>Rust has lots of useful crates that speedup software development quite a lot, but a large portion of these crates heavily rely on the standard library. I can understand the authors: It's often not worth the effort to invest more time for something that will hardly be used. However, I'm sure this will continue to improve as more people and companies are starting to recognize the advantages of Rust for embedded and systems programming.<h3 id=heap-allocations>Heap allocations</h3><p>When I first started writing drivers in Rust, I thought it was simply not possible to use collections like <code>Vec</code>, <code>String</code> or <code>HashMap</code> but then I found <a href=https://rust-embedded.github.io/book/collections/index.html>this</a> page in the Embedded Book. It certainly would have been nice to use these collections, but in the end it didn't really matter. I hardly ever needed them and didn't really notice a difference.<h1 id=conclusion>Conclusion</h1><p>Using Rust for all kinds of projects is fun. No matter if you want to write a game in the browser using WASM, develop a CLI tool or whether you want to explore the depths of the kernel. Writing kernel drivers in Rust is certainly unusual but you can utilize the strong type system and for example the <code>Drop</code> trait to reduce the number of bugs at compile-time. The source code for the driver can be found <a href=https://github.com/not-matthias/kernel-driver-with-rust>here</a>.<p>It has been a long time since I wrote a blog post, I hope you enjoyed reading it. I'd love to hear your thoughts and opinions about this topic.<p>Thanks for reading!</section></article></main></div>